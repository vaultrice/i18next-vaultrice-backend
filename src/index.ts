import { NonLocalStorage } from '@vaultrice/sdk'
import type { KeyDerivationOptions, EncryptionHandler, EncryptionSettings, LogLevel } from '@vaultrice/sdk'

/**
 * Default options for the backend.
 * @internal
 */
const defaults = {
  id: 'shared-i18next-resources'
  // class: '_undefined_'
}

/**
 * Configuration options for the Vaultrice i18next backend.
 */
export interface VaultriceBackendOptions {
  /**
   * Vaultrice credentials required to connect.
   */
  credentials: {
    projectId: string
    apiKey?: string
    apiSecret?: string
    accessToken?: string
  }
  /**
   * Callback invoked when a non-local storage instance is created.
   * This can be used to customize or monitor the storage layer used for translations, such as using
   * a new accessToken. The callback receives the created {@link NonLocalStorage}
   * instance as its argument.
   * @example:
   * let usedNls;
   * onNonLocalStorageCreated((nls) => {
   *   usedNls = nls;
   * });
   * // later, when token needs to be refreshed:
   * // get new token from your backend
   * usedNls.useAccessToken(newAccessToken);
   */
  onNonLocalStorageCreated(nls: NonLocalStorage): unknown
  /**
   * The ID of the Vaultrice object to use. Can be shared globally, or be
   * user/region-specific for data locality.
   * @default 'shared-i18next-resources'
   */
  id?: string
  /**
   * The "class" namespace in Vaultrice, ideal for versioning translations
   * (e.g., 'v1', 'v2', 'production').
   * @default '_undefined_'
   */
  class?: string
  /**
   * Default time-to-live for cached translation items in milliseconds.
   * @default 3600000 (1 hour)
   */
  ttl?: number
  /**
   * A signature generated by your backend to authorize access to an object.
   */
  idSignature?: string
  /**
   * The version of the key used to generate the idSignature.
   */
  idSignatureKeyVersion?: number
  /**
   * Enables client-side End-to-End Encryption (E2EE) for all translations.
   */
  passphrase?: string
  /**
   * Advanced options for key derivation when using a passphrase.
   */
  keyDerivationOptions?: KeyDerivationOptions
  /**
   * A custom function to handle encryption and decryption logic.
   */
  getEncryptionHandler?: (encryptionSettings: EncryptionSettings) => Promise<EncryptionHandler>
  /**
   * Whether to automatically update old encrypted values on read.
   * @default true
   */
  autoUpdateOldEncryptedValues?: boolean
  /**
   * The logging level for the Vaultrice SDK.
   * @default 'warn'
   */
  logLevel?: LogLevel
  /**
   * An interval in milliseconds to automatically poll for updated translations.
   * If set, the backend will periodically reload all loaded resources.
   */
  reloadInterval?: number
}

/**
 * Options passed by the i18next core.
 * @internal
 */
interface AllOptions {
  preload?: string[]
  ns?: string[]
  [key: string]: any
}

type ReadCallback = (err?: any, data?: any) => void

/**
 * An i18next backend that uses Vaultrice for loading and saving translations.
 * It can be used as a primary backend or as a real-time, persistent caching layer.
 * @implements {import('i18next').BackendModule}
 */
class VaultriceBackend {
  /**
   * Defines this as a backend module for i18next.
   */
  static type = 'backend' as const
  type: 'backend'
  services: any
  options: VaultriceBackendOptions
  allOptions: AllOptions
  nls!: NonLocalStorage

  constructor (services: any, options: VaultriceBackendOptions, allOptions: AllOptions = {}) {
    this.type = 'backend'
    this.services = services
    this.options = options || {}
    this.allOptions = allOptions
    this.init(services, options, allOptions)
  }

  /**
   * Initializes the backend, merges options, and creates the Vaultrice client.
   * @param {any} services - i18next services.
   * @param {VaultriceBackendOptions} options - The backend options.
   * @param {AllOptions} allOptions - All i18next options.
   */
  init (services: any, options: VaultriceBackendOptions, allOptions: AllOptions = {}) {
    this.services = services
    this.options = { ...defaults, ...(this.options || {}), ...options }
    this.allOptions = allOptions

    // i18next does not immediately pass the options down
    if (!this.options.credentials) return

    this.nls = new NonLocalStorage(
      this.options.credentials,
      {
        id: this.options.id,
        class: this.options.class,
        ttl: this.options.ttl,
        idSignature: this.options.idSignature,
        idSignatureKeyVersion: this.options.idSignatureKeyVersion,
        passphrase: this.options.passphrase,
        keyDerivationOptions: this.options.keyDerivationOptions,
        getEncryptionHandler: this.options.getEncryptionHandler,
        autoUpdateOldEncryptedValues: this.options.autoUpdateOldEncryptedValues,
        logLevel: this.options.logLevel
      }
    )

    // Pre-fetch encryption settings if encryption is enabled.
    if (this.options.passphrase || this.options.getEncryptionHandler) {
      this.nls.getEncryptionSettings()
    }

    if (typeof this.options.onNonLocalStorageCreated === 'function') {
      this.options.onNonLocalStorageCreated(this.nls)
    }

    // Set up polling interval if configured.
    if (this.services && this.options.reloadInterval) {
      const timer = setInterval(() => this.reload(), this.options.reloadInterval)
      // Allows Node.js process to exit even if the timer is active.
      if (typeof timer === 'object' && typeof timer.unref === 'function') {
        timer.unref()
      }
    }
  }

  /**
   * Reads a single namespace for a given language.
   * @param {string} language - The language to load.
   * @param {string} namespace - The namespace to load.
   * @param {ReadCallback} callback - The callback function.
   */
  read (language: string, namespace: string, callback: ReadCallback) {
    this.nls?.getAllItems({ prefix: `${language}:${namespace}:` })
      .then((items: Record<string, any> | undefined) => {
        const translations: Record<string, any> = {}
        const actualItems = items ?? {}
        for (const key in actualItems) {
          const i18nextKey = key.substring(`${language}:${namespace}:`.length)
          translations[i18nextKey] = actualItems[key].value
        }
        callback(null, translations)
      })
      .catch((err: any) => {
        const errorMessage = err?.message?.toLowerCase()
        const isNetworkError = [
          'failed',
          'fetch',
          'network',
          'load'
        ].find((term) => errorMessage?.indexOf(term) > -1)
        if (isNetworkError) {
          return callback(`failed loading ${language}/${namespace}:${err.message}`, true /* retry */)
        }
        return callback(err, false)
      })
  }

  /**
   * Reads multiple namespaces for multiple languages.
   * @param {string[]} languages - The languages to load.
   * @param {string[]} namespaces - The namespaces to load.
   * @param {ReadCallback} callback - The callback function.
   */
  readMulti (languages: string[], namespaces: string[], callback: ReadCallback) {
    const translations: Record<string, Record<string, Record<string, any>>> = {}
    const proms: Promise<void>[] = []
    languages.forEach((lng) => {
      translations[lng] = {}
      namespaces.forEach((ns) => {
        translations[lng][ns] = {}
        this.nls?.getAllItems({ prefix: `${lng}:${ns}:` })
          .then((items: Record<string, any> | undefined) => {
            const actualItems = items ?? {}
            for (const key in actualItems) {
              const i18nextKey = key.substring(`${lng}:${ns}:`.length)
              translations[lng][ns][i18nextKey] = actualItems[key].value
            }
          }) ?? Promise.resolve()
      })
    })
    Promise.all(proms)
      .then(() => {
        callback(null, translations)
      })
      .catch((err: any) => {
        const errorMessage = err?.message?.toLowerCase()
        const isNetworkError = [
          'failed',
          'fetch',
          'network',
          'load'
        ].find((term) => errorMessage?.indexOf(term) > -1)
        if (isNetworkError) {
          return callback(`failed loading ${languages.join(',')}/${namespaces.join(',')}:${err.message}`, true /* retry */)
        }
        return callback(err, false)
      })
  }

  /**
   * Saves translations for a given language and namespace.
   * @param {string} language - The language to save.
   * @param {string} namespace - The namespace to save.
   * @param {Record<string, any>} data - The key-value translation object.
   */
  save (language: string, namespace: string, data: Record<string, any>) {
    const itemsToSet: Record<string, { value: any }> = {}
    for (const key in data) {
      const vaultriceKey = `${language}:${namespace}:${key}`
      itemsToSet[vaultriceKey] = { value: data[key] }
    }

    if (Object.keys(itemsToSet).length > 0) {
      this.nls?.setItems(itemsToSet)
        .catch((err) => {
          console.error(`Failed to save translations for ${language}/${namespace}:`, err)
        })
    }
  }

  /**
   * Creates a new translation key if it's missing.
   * @param {string[] | string} languages - The language(s) to add the key to.
   * @param {string} namespace - The namespace for the key.
   * @param {string} key - The new translation key.
   * @param {any} fallbackValue - The value to set for the new key.
   * @param {ReadCallback} [callback] - Optional callback.
   */
  create (
    languages: string[] | string,
    namespace: string,
    key: string,
    fallbackValue?: any,
    callback?: ReadCallback
  ) {
    if (typeof languages === 'string') languages = [languages]
    let clb: ReadCallback = () => {}
    if (typeof callback === 'function') clb = callback

    const itemsToSet: Record<string, { value: any; ifAbsent: boolean }> = {}
    for (const lng of languages) {
      const vaultriceKey = `${lng}:${namespace}:${key}`
      itemsToSet[vaultriceKey] = { value: fallbackValue || key, ifAbsent: true }
    }
    if (Object.keys(itemsToSet).length === 0) return clb()

    this.nls?.setItems(itemsToSet)
      .then((res: any) => clb(null, res))
      .catch(clb)
  }

  /**
   * Triggers a reload of resources based on the current language and preload options.
   */
  reload () {
    const { backendConnector, languageUtils, logger } = this.services
    if (!backendConnector) return

    const currentLanguage = backendConnector.language
    if (currentLanguage && currentLanguage.toLowerCase() === 'cimode') return

    const languagesToLoad: Set<string> = new Set()
    const addLanguage = (lng: string) => {
      languageUtils.toResolveHierarchy(lng).forEach((l: string) => languagesToLoad.add(l))
    }

    if (currentLanguage) {
      addLanguage(currentLanguage)
    }
    if (this.allOptions.preload) {
      this.allOptions.preload.forEach((l: string) => addLanguage(l))
    }

    this.allOptions.ns?.forEach((ns: string) => {
      languagesToLoad.forEach((lng: string) => {
        backendConnector.read(lng, ns, 'read', null, null, (err: any, data: any) => {
          if (err) logger.warn(`loading namespace ${ns} for language ${lng} failed`, err)
          if (!err && data) logger.log(`loaded namespace ${ns} for language ${lng}`, data)
          backendConnector.loaded(`${lng}|${ns}`, err, data)
        })
      })
    })
  }
}

export default VaultriceBackend
